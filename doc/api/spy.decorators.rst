*********************
:mod:`spy.decorators`
*********************

This module contains various function decorators for use in spy fragments.

.. module:: spy.decorators

.. decorator:: accumulate

   .. option:: --accumulate, -a

   Accumulate values into an iterator by calling :func:`spy.collect`, and pass
   that to the fragment.

   This can be used to write a fragment which executes at most once while
   passing data through:

   ``-ma 'x = y;'``

.. decorator:: callable

   .. option:: --callable, -c

   Call the result of the decorated fragment

.. decorator:: filter

   .. option:: --filter, -f

   Use the decorated fragment as a predicate—only elements for which the
   fragment returns a true value will be passed through.

.. decorator:: keywords

   .. option:: --keywords, -k

   On fragments generated by the CLI, sets the local scope to the input value
   before each invocation. Normal Python functions cannot do this—trying to
   decorate them will raise :exception:`ValueError`.

.. decorator:: many

   .. option:: --many, -m

   Call :func:`spy.many` with the result of the fragment.


Literal decorators
==================

On the CLI, these decorators take a literal string rather than Python code.
In Python-land, they expect to decorate a function that
returns ``(scope, string)``. They're especially pointless for non-CLI uses,
and this documentation is written with CLI usage in mind.

.. decorator:: interpolate

   .. option:: --interpolate, -i

   Interpolate the literal argument as a :meth:`str.format` format string.

   Keyword substitutions (``{foo}``) look up variable names. Positional
   substitutions (``{2}``) are indexes into the value being processed.

.. decorator:: regex

   .. option:: --regex, --regexp, -R

   Match a regexp against the input using :func:`re.match`.
